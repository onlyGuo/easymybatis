<h2>实体类定义</h2>

<p>为保证实体类多项目的通用性, 不要将新的实体类定义到你应用的项目中.
应抽离出来, 定义在<code>entity</code>项目中, 以此来供给多个项目引用使用. 
主要解决以下问题:
- 方便管理;
- 避免了在项目之间通信的时候, 由于两方所使用的实体类字段不一致导致数据异常的问题
- 避免了实体类字段发生变动时, 每个项目都需要修改一遍的问题.</p>

<h4>命名规范</h4>

<ul><li>持久化对象(对应数据库的表): XXXPO</li><li>值对象(可以是任何场景中的值): XXXVO</li><li>系列化对象(跨服务之间的通信对象, 或与客户端通信的对象) XXXDTO</li></ul>

<blockquote><p>一般情况下, 使用VO即可, 在复杂场景中, 可以PO与VO分开来使用. 在一些特殊场景中, (例如统计图等相关接口中) 需要给客户端传利高度封装的定制对象时使用DTO.</p></blockquote>

<h4>一个复杂的实体类定义</h4>

<p><code></code>java
/**
 <em> @author gsk 
 </em> <code>@TableName</code>注解中的name值 标识该实体类对应数据库中的表名
 <em> 继承PO类, 则表示这个实体类可以对数据库中对应的表进行操作
 </em>/
@TableName(name = &quot;persion_info&quot;)
public class PersionPO extends PO{</p>

<pre><code>/**
 * 对应数据库的主键字段(该注解支持字段的类型有: int, long, String)
 */
@ID
private Long id;

/**
 * `@FieldName`注解中的name值 标识该字段对应数据库表中的指定字段名
 */
@FieldName(name = &quot;persion_name&quot;)
private String name;

/**
 * 不使用@FieldName 注解时, 系统会使用当前字段名作为数据库表中的字段名进行操作
 * (会转换为下划线命名方式)
 * 例如该字段, 系统会默认认为它对应数据库的字段名为`age_num`
 */
private String ageNum;

/**
 * 该`@TempField`注解标识这个字段不参与数据库操作.
 */
@TempField
private int nicker;

// getter .... setter</code></pre>

<p>}
<code></code></p>

<h2>数据库操作类(DAO)</h2>

<h4>创建DAO</h4>

<p>简单而言, 数据库操作类直接继承BaseDaoImpl即可实现几乎所有的数据库操作, 
尽量避免使用自动生成Mapper, 避免日后实体类有改动时, Mapper要同步修改, 
避免实体类和mapper不同步问题. 代码如下: 
<code>java
/**
 * @author gsk 
 */
@Repository
public class PersionDao extends BaseDaoImpl&lt;PersionPO, Long&gt; {
    // 此处无需写过多的代码. BaseDaoImpl本身实现了公共的数据库操作.
}
</code></p>

<h4>声明和使用DAO</h4>

<ul><li><p>一个简单的代码实例, 无需写SQL, 简单的一行代码就实现了多条件, 分页, 排序等功能: 
<code></code>java
/**</p><ul><li><p>@author gsk 
*/
@Service
public class PersionServiceImpl implements PersionService {</p><p>@Resource
private PersionDao persionDao;</p><p>/**</p><ul><li>列出年轻的小姐姐列表, 并案年龄倒序排序</li><li>@param pageNum</li><li>页码</li><li>@param length</li><li>每页长度</li><li>@return 
<em>/
public List&lt;PersionPO&gt; listYoungGirl(int pageNum, int length){
long startNum = (pageNum - 1) </em> length;
// 18岁及18岁以下的定义为年轻, sex = 0 定义为女
return persionDao.list(Method.where(&quot;age<em>num&quot;, C.XE, 18).and(&quot;sex&quot;, C.EQ, 0).limit(startNum, length).orderBy(&quot;age</em>num desc&quot;));
}
}
<code></code></li></ul></li></ul></li></ul>

<h4>DAO中的Method表达式</h4>

<blockquote><p>DAO中, 大部分的操作会用到Method表达式, Method表达式为链式操作, 且不用在意顺序. 
可以根据业务判断和流程在不同的场景中动态构建你所需的<code>SQL WHERE 表达式</code>, 它表达了我们要查询的数据库的目标.
主要分为[字段名, 比较符, 比较值] 三部分.</p></blockquote>

<p>示例(目标为: 18岁的人群中的小姐姐按照年龄倒序的前十条):
<code>java
// 18岁的人群
WherePrams where = Method.where(&quot;age_num&quot;, C.EQ, 18);
// 中的小姐姐
where.and(&quot;sex&quot;, C.EQ, 0);
// 按照年龄倒序
where.orderBy(&quot;age_num desc&quot;);
// 的前十条
where.limit(0, 10);
</code></p>

<blockquote><p>当不确定首要条件的时候, 可以用createDefault()方法创建一个无目标的表达式.</p></blockquote>

<p>示例(当传入年龄 &lt;= 18时, 取出10个18岁小姐姐, 否则取出20个指定年龄的小哥哥)
<code></code>java
public List&lt;PersionPO&gt; list(int age){
    WherePrams where = Method.createDefault();</p>

<pre><code>if(age &lt;= 18){
    where.and(&quot;age_num&quot;, C.EQ, 18).and(&quot;sex&quot;, C.EQ, 0).limit(0, 10);
}else{
    where.and(&quot;age_num&quot;, C.EQ, age).and(&quot;sex&quot;, C.EQ, 1).limit(0, 20);
}

return persionDao.list(where);</code></pre>

<p>}
<code></code></p>

<h4>DAO 的高级用法(自定义SQL)</h4>

<ul><li>用法一, 封装自定义SQL
&gt; 直接在DAO实现类中添加自定义SQL方法即可, 假设每个人都有一个朋友, 
并且他们是自关联的表, 这个时候要查询出所有小哥哥的女朋友, 并且分页展示, 
这个时候需要执行一个比较复杂的SQL, 
如下:
<code></code>sql
SELECT res.* FROM persion<em>info WHERE res.id IN (
SELECT friendId FROM persion</em>info WHERE sex = 1
) res LIMIT 0, 10;</li></ul>

<p><code></code>
- 让DAO原生支持这个SQL&lt;br/&gt;
只需建立这个SQL的实现方法即可.</p>

<p><code></code>java
/**
 <em> @author gsk 
 </em>/
@Repository
public class PersionDao extends BaseDaoImpl&lt;PersionPO, Long&gt; {</p>

<pre><code>/**
 * 出所有小哥哥的女朋友, 并且分页展示
 * @param pageNum
 *      页码
 * @param length
 *      每页条数
 * @return 
 */
List&lt;PersionPO&gt; listPersionFriend(int pageNum, int length){
    int start = (pageNum - 1) * length;
    String sql = &quot;SELECT res.* FROM (&quot; + 
                 &quot;    SELECT friendId FROM persion_info WHERE sex = ?&quot; + 
                 &quot;) res LIMIT ?, ?;&quot;;
    return list(sql, 1, start, length);
}</code></pre>

<p>}
<code>
- 使用内部函数优化SQL语句&lt;br/&gt;
在以上代码中, 要查询的字段是 res.*, 这个过程其实比较耗时, 我需要更规范的写法: `SELECT res.id, res.name, res.xxx ... FROM`这类的.
再比如`SELECT friendId FROM persion_info`中的`persion_info`这个表名, 也是写死的, 假设表名变更或者字段变更的话, 
则需要修改业务代码, 这个时候使用内部函数来动态得到要查询的字段和表名, 便可解决后期的SQL维护问题. 
如下:
</code>java
List&lt;PersionPO&gt; listPersionFriend(int pageNum, int length){
    int start = (pageNum - 1) * length;</p>

<pre><code>// 动态生成SQL, 填充字段列表和表名
String sql = &quot;SELECT %s FROM (&quot; + 
             &quot;    SELECT friendId FROM %s WHERE sex = ?&quot; + 
             &quot;) LIMIT ?, ?;&quot;;
sql = String.format(sql, selectSql(), tableName());

// 执行SQL
return list(sql, 1, start, length);</code></pre>

<p>}
<code></code></p>

<h4>DAO的高级用法(使用Mybatis特性: Mapper)</h4>

<p>继续以以上SQL为例, 将以上Sql使用Mapper模板来执行: 
1. 建立Mapper.xml
<code></code>xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</p>

<p>&lt;mapper namespace=&quot;com.front.pay.dao.PersionDao&quot;&gt;
    &lt;select id=&quot;listPersionFriend&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;com.front.entity.PersionPO&quot;&gt;
        SELECT ${selectSql} FROM (
            SELECT friendId FROM ${tableName} WHERE sex = #{sex}
        ) res LIMIT #{start}, #{length};
    &lt;/select&gt;
&lt;/mapper&gt;
<code>
2. 添加DAO方法映射
</code>java
/**
 <em> @author gsk 
 </em>/
@Repository
public class PersionDao extends BaseDaoImpl&lt;PersionPO, Long&gt; {</p>

<pre><code>@Resource
private SqlSessionTemplate sqlSessionTemplate;

/**
 * 出所有小哥哥的女朋友, 并且分页展示
 * @param pageNum
 *      页码
 * @param length
 *      每页条数
 * @return 
 */
List&lt;PersionPO&gt; listPersionFriend(int pageNum, int length){
    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
    params.put(&quot;start&quot;, (pageNum - 1) * length);
    params.put(&quot;length&quot;, length);
    params.put(&quot;selectSql&quot;, selectSql());
    params.put(&quot;tableName&quot;, tableName());

    return sqlSessionTemplate.selectList(&quot;listPersionFriend&quot;, params);
}</code></pre>

<p>}
<code>
其实以上语句是可以使用强大的Method表达式动态生成的, 善用`Script`对象, 它可以生成你想要的SQL脚本而不执行它:
</code>java
Method.where(&quot;id&quot;, C.IN, 
    Script.of(&quot;SELECT parentId FROM &quot;, tableName(), &quot; &quot;, Method.where(&quot;sex&quot;, 1))
).limit(1, 10);
<code></code></p>

<p>待续...</p>
